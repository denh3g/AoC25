{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/home/code/AoC25/app/%5Bday%5D/solutions/day4/solver.jsx"],"sourcesContent":["export async function solveDay4(input) {\n    let partA = 0;\n    let partB = 0;\n\n    let solveA = solver(input);\n\n    partA = solveA.total;\n    partB += partA;\n    let grid = solveA.grid;\n    let solveB = { total: partB, grid };\n\n    while (solveB.total > 0) {\n        solveB = solver(input, solveB.grid);\n        partB += solveB.total;\n    }\n\n    console.log(partB);\n    return { partA, partB };\n}\n\n\nconst solver = (input, grid) => {\n    let total = 0;\n    if (!grid) grid = input.split(\"\\n\").map(row => row.split(''));\n\n    const dirs = [\n        [0, -1],  // N\n        [1, 0],   // E\n        [0, 1],   // S\n        [-1, 0],  // W\n        [-1, -1], // NW\n        [-1, 1],  // NE\n        [1, -1],  // SW\n        [1, 1],   // SE\n    ];\n\n    const validCells = [];\n\n    for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n            if (grid[y][x] !== '@') continue;\n\n            let counter = 0;\n\n            for (const [dx, dy] of dirs) {\n                let nx = x + dx;\n                let ny = y + dy;\n\n                while (\n                    ny >= 0 && ny < grid.length &&\n                    nx >= 0 && nx < grid[0].length\n                ) {\n                    if (grid[ny][nx] === '@') {\n                        counter++;\n                        break;\n                    }\n\n                    // Stop at anything that isnâ€™t an empty space\n                    if (grid[ny][nx] !== '.' || grid[ny][nx] !== '@') break;\n\n                    nx += dx;\n                    ny += dy;\n                }\n            }\n\n            if (counter < 4) {\n                total++;\n                validCells.push([y, x]);\n            }\n        }\n    }\n\n    // Mark cells for removal\n    validCells.forEach(([y, x]) => {\n        grid[y][x] = 'x';\n    });\n\n    return { total, grid };\n};\n"],"names":[],"mappings":";;;;AAAO,eAAe,UAAU,KAAK;IACjC,IAAI,QAAQ;IACZ,IAAI,QAAQ;IAEZ,IAAI,SAAS,OAAO;IAEpB,QAAQ,OAAO,KAAK;IACpB,SAAS;IACT,IAAI,OAAO,OAAO,IAAI;IACtB,IAAI,SAAS;QAAE,OAAO;QAAO;IAAK;IAElC,MAAO,OAAO,KAAK,GAAG,EAAG;QACrB,SAAS,OAAO,OAAO,OAAO,IAAI;QAClC,SAAS,OAAO,KAAK;IACzB;IAEA,QAAQ,GAAG,CAAC;IACZ,OAAO;QAAE;QAAO;IAAM;AAC1B;AAGA,MAAM,SAAS,CAAC,OAAO;IACnB,IAAI,QAAQ;IACZ,IAAI,CAAC,MAAM,OAAO,MAAM,KAAK,CAAC,MAAM,GAAG,CAAC,CAAA,MAAO,IAAI,KAAK,CAAC;IAEzD,MAAM,OAAO;QACT;YAAC;YAAG,CAAC;SAAE;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC,CAAC;YAAG;SAAE;QACP;YAAC,CAAC;YAAG,CAAC;SAAE;QACR;YAAC,CAAC;YAAG;SAAE;QACP;YAAC;YAAG,CAAC;SAAE;QACP;YAAC;YAAG;SAAE;KACT;IAED,MAAM,aAAa,EAAE;IAErB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;QAClC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAK;YACrC,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,KAAK;YAExB,IAAI,UAAU;YAEd,KAAK,MAAM,CAAC,IAAI,GAAG,IAAI,KAAM;gBACzB,IAAI,KAAK,IAAI;gBACb,IAAI,KAAK,IAAI;gBAEb,MACI,MAAM,KAAK,KAAK,KAAK,MAAM,IAC3B,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,CAAC,MAAM,CAChC;oBACE,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,KAAK;wBACtB;wBACA;oBACJ;oBAEA,6CAA6C;oBAC7C,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,KAAK;oBAElD,MAAM;oBACN,MAAM;gBACV;YACJ;YAEA,IAAI,UAAU,GAAG;gBACb;gBACA,WAAW,IAAI,CAAC;oBAAC;oBAAG;iBAAE;YAC1B;QACJ;IACJ;IAEA,yBAAyB;IACzB,WAAW,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE;QACtB,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG;IACjB;IAEA,OAAO;QAAE;QAAO;IAAK;AACzB"}}]
}